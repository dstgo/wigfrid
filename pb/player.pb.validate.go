// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: player.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PlayerInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayerInfoMultiError, or
// nil if none found.
func (m *PlayerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SteamId

	// no validation rules for Kid

	// no validation rules for Name

	// no validation rules for Role

	// no validation rules for Admin

	if len(errors) > 0 {
		return PlayerInfoMultiError(errors)
	}

	return nil
}

// PlayerInfoMultiError is an error wrapping multiple validation errors
// returned by PlayerInfo.ValidateAll() if the designated constraints aren't met.
type PlayerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerInfoMultiError) AllErrors() []error { return m }

// PlayerInfoValidationError is the validation error returned by
// PlayerInfo.Validate if the designated constraints aren't met.
type PlayerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerInfoValidationError) ErrorName() string { return "PlayerInfoValidationError" }

// Error satisfies the builtin error interface
func (e PlayerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerInfoValidationError{}

// Validate checks the field values on BasicPlayerInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BasicPlayerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BasicPlayerInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BasicPlayerInfoMultiError, or nil if none found.
func (m *BasicPlayerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BasicPlayerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for Name

	if len(errors) > 0 {
		return BasicPlayerInfoMultiError(errors)
	}

	return nil
}

// BasicPlayerInfoMultiError is an error wrapping multiple validation errors
// returned by BasicPlayerInfo.ValidateAll() if the designated constraints
// aren't met.
type BasicPlayerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BasicPlayerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BasicPlayerInfoMultiError) AllErrors() []error { return m }

// BasicPlayerInfoValidationError is the validation error returned by
// BasicPlayerInfo.Validate if the designated constraints aren't met.
type BasicPlayerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BasicPlayerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BasicPlayerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BasicPlayerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BasicPlayerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BasicPlayerInfoValidationError) ErrorName() string { return "BasicPlayerInfoValidationError" }

// Error satisfies the builtin error interface
func (e BasicPlayerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBasicPlayerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BasicPlayerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BasicPlayerInfoValidationError{}

// Validate checks the field values on PlayerStatisticInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlayerStatisticInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerStatisticInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlayerStatisticInfoMultiError, or nil if none found.
func (m *PlayerStatisticInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerStatisticInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Online

	// no validation rules for MasterOnline

	// no validation rules for CaveOnline

	for idx, item := range m.GetMasterOnlinePlayer() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PlayerStatisticInfoValidationError{
						field:  fmt.Sprintf("MasterOnlinePlayer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PlayerStatisticInfoValidationError{
						field:  fmt.Sprintf("MasterOnlinePlayer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PlayerStatisticInfoValidationError{
					field:  fmt.Sprintf("MasterOnlinePlayer[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCaveOnlinePlayer() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PlayerStatisticInfoValidationError{
						field:  fmt.Sprintf("CaveOnlinePlayer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PlayerStatisticInfoValidationError{
						field:  fmt.Sprintf("CaveOnlinePlayer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PlayerStatisticInfoValidationError{
					field:  fmt.Sprintf("CaveOnlinePlayer[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PlayerStatisticInfoMultiError(errors)
	}

	return nil
}

// PlayerStatisticInfoMultiError is an error wrapping multiple validation
// errors returned by PlayerStatisticInfo.ValidateAll() if the designated
// constraints aren't met.
type PlayerStatisticInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerStatisticInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerStatisticInfoMultiError) AllErrors() []error { return m }

// PlayerStatisticInfoValidationError is the validation error returned by
// PlayerStatisticInfo.Validate if the designated constraints aren't met.
type PlayerStatisticInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerStatisticInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerStatisticInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerStatisticInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerStatisticInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerStatisticInfoValidationError) ErrorName() string {
	return "PlayerStatisticInfoValidationError"
}

// Error satisfies the builtin error interface
func (e PlayerStatisticInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerStatisticInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerStatisticInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerStatisticInfoValidationError{}

// Validate checks the field values on LogMessage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogMessageMultiError, or
// nil if none found.
func (m *LogMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *LogMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Time

	// no validation rules for Event

	// no validation rules for Msg

	if len(errors) > 0 {
		return LogMessageMultiError(errors)
	}

	return nil
}

// LogMessageMultiError is an error wrapping multiple validation errors
// returned by LogMessage.ValidateAll() if the designated constraints aren't met.
type LogMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogMessageMultiError) AllErrors() []error { return m }

// LogMessageValidationError is the validation error returned by
// LogMessage.Validate if the designated constraints aren't met.
type LogMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogMessageValidationError) ErrorName() string { return "LogMessageValidationError" }

// Error satisfies the builtin error interface
func (e LogMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogMessageValidationError{}

// Validate checks the field values on PlayerChatLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayerChatLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerChatLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayerChatLogMultiError, or
// nil if none found.
func (m *PlayerChatLog) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerChatLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PlayerChatLogValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PlayerChatLogValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PlayerChatLogValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PlayerChatLogMultiError(errors)
	}

	return nil
}

// PlayerChatLogMultiError is an error wrapping multiple validation errors
// returned by PlayerChatLog.ValidateAll() if the designated constraints
// aren't met.
type PlayerChatLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerChatLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerChatLogMultiError) AllErrors() []error { return m }

// PlayerChatLogValidationError is the validation error returned by
// PlayerChatLog.Validate if the designated constraints aren't met.
type PlayerChatLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerChatLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerChatLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerChatLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerChatLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerChatLogValidationError) ErrorName() string { return "PlayerChatLogValidationError" }

// Error satisfies the builtin error interface
func (e PlayerChatLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerChatLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerChatLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerChatLogValidationError{}

// Validate checks the field values on ExecutePlayerReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExecutePlayerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutePlayerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecutePlayerReqMultiError, or nil if none found.
func (m *ExecutePlayerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutePlayerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstanceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutePlayerReqValidationError{
					field:  "InstanceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutePlayerReqValidationError{
					field:  "InstanceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutePlayerReqValidationError{
				field:  "InstanceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutePlayerReqValidationError{
					field:  "Kid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutePlayerReqValidationError{
					field:  "Kid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutePlayerReqValidationError{
				field:  "Kid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Op

	if len(errors) > 0 {
		return ExecutePlayerReqMultiError(errors)
	}

	return nil
}

// ExecutePlayerReqMultiError is an error wrapping multiple validation errors
// returned by ExecutePlayerReq.ValidateAll() if the designated constraints
// aren't met.
type ExecutePlayerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutePlayerReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutePlayerReqMultiError) AllErrors() []error { return m }

// ExecutePlayerReqValidationError is the validation error returned by
// ExecutePlayerReq.Validate if the designated constraints aren't met.
type ExecutePlayerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutePlayerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutePlayerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutePlayerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutePlayerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutePlayerReqValidationError) ErrorName() string { return "ExecutePlayerReqValidationError" }

// Error satisfies the builtin error interface
func (e ExecutePlayerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutePlayerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutePlayerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutePlayerReqValidationError{}

// Validate checks the field values on PlayerListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayerListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayerListReqMultiError, or
// nil if none found.
func (m *PlayerListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstanceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlayerListReqValidationError{
					field:  "InstanceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlayerListReqValidationError{
					field:  "InstanceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlayerListReqValidationError{
				field:  "InstanceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlayerListReqValidationError{
					field:  "Kid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlayerListReqValidationError{
					field:  "Kid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlayerListReqValidationError{
				field:  "Kid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PlayerListReqMultiError(errors)
	}

	return nil
}

// PlayerListReqMultiError is an error wrapping multiple validation errors
// returned by PlayerListReq.ValidateAll() if the designated constraints
// aren't met.
type PlayerListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerListReqMultiError) AllErrors() []error { return m }

// PlayerListReqValidationError is the validation error returned by
// PlayerListReq.Validate if the designated constraints aren't met.
type PlayerListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerListReqValidationError) ErrorName() string { return "PlayerListReqValidationError" }

// Error satisfies the builtin error interface
func (e PlayerListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerListReqValidationError{}

// Validate checks the field values on PlayerListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayerListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayerListRespMultiError,
// or nil if none found.
func (m *PlayerListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PlayerListRespValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PlayerListRespValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PlayerListRespValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PlayerListRespMultiError(errors)
	}

	return nil
}

// PlayerListRespMultiError is an error wrapping multiple validation errors
// returned by PlayerListResp.ValidateAll() if the designated constraints
// aren't met.
type PlayerListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerListRespMultiError) AllErrors() []error { return m }

// PlayerListRespValidationError is the validation error returned by
// PlayerListResp.Validate if the designated constraints aren't met.
type PlayerListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerListRespValidationError) ErrorName() string { return "PlayerListRespValidationError" }

// Error satisfies the builtin error interface
func (e PlayerListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerListRespValidationError{}
